<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotion Flocking Visualization - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        button {
            background-color: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Emotion Flocking Visualization</h3>
        <p>Press 'F' for fullscreen<br>Press 'S' to save screenshot</p>
    </div>
    <div id="controls">
        <div>
            <label>Align: <span id="alignValue">1.5</span></label>
            <input type="range" id="alignSlider" min="0" max="3" step="0.1" value="1.5">
        </div>
        <div>
            <label>Cohesion: <span id="cohesionValue">1.0</span></label>
            <input type="range" id="cohesionSlider" min="0" max="3" step="0.1" value="1.0">
        </div>
        <div>
            <label>Separation: <span id="separationValue">2.0</span></label>
            <input type="range" id="separationSlider" min="0" max="3" step="0.1" value="2.0">
        </div>
        <div>
            <button id="traceToggle">Trace: ON</button>
            <button id="resetButton">Reset</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@v0.180.0/build/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.149.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Post-processing setup
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.5, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);

        // Camera position
        camera.position.z = 50;

        // Controls
        const controls = {
            align: 1.5,
            cohesion: 1.0,
            separation: 2.0,
            trace: true,
            numParticles: 2000
        };

        // Palette colors for particles
        const palette = [
            new THREE.Color(1.0, 0.894, 0.294), // Bright yellow
            new THREE.Color(0.0196, 0.5098, 0.0039), // Dark green
            new THREE.Color(0.4824, 0.0, 1.0), // Vivid purple
            new THREE.Color(1.0, 0.3333, 0.0), // Deep orange
            new THREE.Color(1.0, 0.1137, 1.0), // Bright pink
            new THREE.Color(0.1804, 0.1804, 1.0), // Deep blue
            new THREE.Color(1.0, 0.0, 0.5019) // Strong pink
        ];

        // Attractor colors
        const attractorColors = [
            new THREE.Color(0.0, 0.749, 1.0), // Cyan
            new THREE.Color(0.0, 1.0, 0.7019), // Mint
            new THREE.Color(1.0, 0.0, 0.0), // Red
            new THREE.Color(1.0, 0.647, 0.0), // Orange
            new THREE.Color(0.5, 0.0, 0.5) // Purple
        ];

        // Constants
        const ATTRACTION_RADIUS = 15;
        const CAPTURE_RADIUS = 5; // Radius where particles are considered "captured"
        const FORCE_PULSE_SPEED = 0.02;
        const WORLD_BOUNDS = 50;

        // Trace system
        const traceGeometry = new THREE.BufferGeometry();
        const tracePositions = new Float32Array(controls.numParticles * 3 * 10);
        const traceColors = new Float32Array(controls.numParticles * 3 * 10);
        const traceOpacities = new Float32Array(controls.numParticles * 10);
        
        // Initialize trace arrays
        for (let i = 0; i < controls.numParticles * 10; i++) {
            traceOpacities[i] = 0;
        }

        traceGeometry.setAttribute('position', new THREE.BufferAttribute(tracePositions, 3));
        traceGeometry.setAttribute('color', new THREE.BufferAttribute(traceColors, 3));
        traceGeometry.setAttribute('opacity', new THREE.BufferAttribute(traceOpacities, 1));

        const traceMaterial = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending
        });

        const traceParticles = new THREE.Points(traceGeometry, traceMaterial);
        scene.add(traceParticles);

        // Main particle system
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(controls.numParticles * 3);
        const particleColors = new Float32Array(controls.numParticles * 3);
        const particleVelocities = [];
        const particleAccelerations = [];
        const particleOriginalColors = [];
        const particleCurrentColors = [];
        
        // New particle states for attraction behavior
        const particleStates = []; // 'free', 'attracted', 'captured', 'repelling'
        const particleCaptureTimes = []; // How long particle has been captured
        const particleCurrentAttractors = []; // Which attractor is currently influencing the particle
        const MAX_CAPTURE_TIME = 2.0; // Maximum time to be captured (in seconds)

        // Initialize particles
        for (let i = 0; i < controls.numParticles; i++) {
            const i3 = i * 3;
            particlePositions[i3] = (Math.random() - 0.5) * WORLD_BOUNDS * 2;
            particlePositions[i3 + 1] = (Math.random() - 0.5) * WORLD_BOUNDS * 2;
            particlePositions[i3 + 2] = 0;

            const colorIndex = Math.floor(Math.random() * palette.length);
            const originalColor = palette[colorIndex];
            particleColors[i3] = originalColor.r;
            particleColors[i3 + 1] = originalColor.g;
            particleColors[i3 + 2] = originalColor.b;

            particleOriginalColors.push(originalColor.clone());
            particleCurrentColors.push(originalColor.clone());
            
            // Initialize new state arrays
            particleStates.push('free');
            particleCaptureTimes.push(0);
            particleCurrentAttractors.push(null);

            particleVelocities.push(new THREE.Vector3(
                (Math.random() - 0.5) * 0.07,
                (Math.random() - 0.5) * 0.07,
                0
            ));

            particleAccelerations.push(new THREE.Vector3(0, 0, 0));
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Attractors
        const attractors = [];
        const attractorMeshes = [];

        for (let i = 0; i < 5; i++) {
            const attractor = {
                position: new THREE.Vector3(
                    (Math.random() - 0.5) * WORLD_BOUNDS * 1.5,
                    (Math.random() - 0.5) * WORLD_BOUNDS * 1.5,
                    0
                ),
                baseStrength: 1.5, // Strong attraction
                repulsionStrength: 2.0, // Even stronger repulsion
                currentStrength: 0,
                pulsePhase: Math.random() * Math.PI * 2,
                color: attractorColors[i],
                radius: 1.5 + Math.random() * 1,
                influenceColor: attractorColors[i]
            };

            attractors.push(attractor);

            // Create visual representation for attractor
            const geometry = new THREE.RingGeometry(attractor.radius * 0.8, attractor.radius, 32);
            const material = new THREE.MeshBasicMaterial({
                color: attractor.color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.copy(attractor.position);
            scene.add(ring);
            attractorMeshes.push(ring);
        }

        // Simplified QuadTree implementation
        class QuadTree {
            constructor(bounds, capacity = 4) {
                this.bounds = bounds;
                this.capacity = capacity;
                this.points = [];
                this.divided = false;
            }

            subdivide() {
                const x = this.bounds.x;
                const y = this.bounds.y;
                const w = this.bounds.width / 2;
                const h = this.bounds.height / 2;

                this.northeast = new QuadTree({ x: x + w, y: y, width: w, height: h }, this.capacity);
                this.northwest = new QuadTree({ x: x, y: y, width: w, height: h }, this.capacity);
                this.southeast = new QuadTree({ x: x + w, y: y + h, width: w, height: h }, this.capacity);
                this.southwest = new QuadTree({ x: x, y: y + h, width: w, height: h }, this.capacity);

                this.divided = true;
            }

            insert(point) {
                if (!this.contains(point)) {
                    return false;
                }

                if (this.points.length < this.capacity) {
                    this.points.push(point);
                    return true;
                }

                if (!this.divided) {
                    this.subdivide();
                }

                return this.northeast.insert(point) ||
                       this.northwest.insert(point) ||
                       this.southeast.insert(point) ||
                       this.southwest.insert(point);
            }

            contains(point) {
                return point.x >= this.bounds.x &&
                       point.x <= this.bounds.x + this.bounds.width &&
                       point.y >= this.bounds.y &&
                       point.y <= this.bounds.y + this.bounds.height;
            }

            query(range, found = []) {
                if (!this.intersects(range)) {
                    return found;
                }

                for (let p of this.points) {
                    if (this.pointInRange(p, range)) {
                        found.push(p);
                    }
                }

                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }

                return found;
            }

            intersects(range) {
                return !(range.x > this.bounds.x + this.bounds.width ||
                        range.x + range.width < this.bounds.x ||
                        range.y > this.bounds.y + this.bounds.height ||
                        range.y + range.height < this.bounds.y);
            }

            pointInRange(point, range) {
                const dx = point.x - range.x;
                const dy = point.y - range.y;
                return Math.sqrt(dx * dx + dy * dy) <= range.radius;
            }

            clear() {
                this.points = [];
                this.divided = false;
                if (this.northeast) {
                    this.northeast.clear();
                    this.northwest.clear();
                    this.southeast.clear();
                    this.southwest.clear();
                }
            }
        }

        // Initialize QuadTree
        const quadTree = new QuadTree({
            x: -WORLD_BOUNDS,
            y: -WORLD_BOUNDS,
            width: WORLD_BOUNDS * 2,
            height: WORLD_BOUNDS * 2
        }, 8);

        // Trace management
        let traceIndex = 0;
        const TRACE_LENGTH = 10;

        function updateTrace() {
            if (!controls.trace) return;

            const position = particles.geometry.attributes.position;
            const colors = particles.geometry.attributes.color;
            const tracePositionsAttr = traceGeometry.getAttribute('position');
            const traceColorsAttr = traceGeometry.getAttribute('color');
            const traceOpacitiesAttr = traceGeometry.getAttribute('opacity');

            // Update trace positions and colors
            for (let i = 0; i < controls.numParticles; i++) {
                const i3 = i * 3;
                const traceI3 = (i * TRACE_LENGTH + traceIndex) * 3;
                
                tracePositionsAttr.array[traceI3] = position.array[i3];
                tracePositionsAttr.array[traceI3 + 1] = position.array[i3 + 1];
                tracePositionsAttr.array[traceI3 + 2] = position.array[i3 + 2];
                
                traceColorsAttr.array[traceI3] = colors.array[i3];
                traceColorsAttr.array[traceI3 + 1] = colors.array[i3 + 1];
                traceColorsAttr.array[traceI3 + 2] = colors.array[i3 + 2];
                
                traceOpacitiesAttr.array[i * TRACE_LENGTH + traceIndex] = 1.0;
            }

            // Fade all traces
            for (let i = 0; i < controls.numParticles * TRACE_LENGTH; i++) {
                traceOpacitiesAttr.array[i] *= 0.85;
            }

            tracePositionsAttr.needsUpdate = true;
            traceColorsAttr.needsUpdate = true;
            traceOpacitiesAttr.needsUpdate = true;

            traceIndex = (traceIndex + 1) % TRACE_LENGTH;
        }

        function clearTrace() {
            const traceOpacitiesAttr = traceGeometry.getAttribute('opacity');
            for (let i = 0; i < controls.numParticles * TRACE_LENGTH; i++) {
                traceOpacitiesAttr.array[i] = 0;
            }
            traceOpacitiesAttr.needsUpdate = true;
        }

        // New attraction system with state machine - ATTRACTION THEN REPULSION
        function handleAttraction(particleIndex) {
            const position = particles.geometry.attributes.position;
            const i3 = particleIndex * 3;
            const x = position.array[i3];
            const y = position.array[i3 + 1];
            const particlePos = new THREE.Vector3(x, y, 0);

            const currentState = particleStates[particleIndex];
            const currentAttractor = particleCurrentAttractors[particleIndex];

            // Check for nearby attractors
            let closestAttractor = null;
            let minDist = Infinity;

            for (let attractor of attractors) {
                const d = particlePos.distanceTo(attractor.position);
                if (d < ATTRACTION_RADIUS && d < minDist) {
                    minDist = d;
                    closestAttractor = attractor;
                }
            }

            // State transitions
            switch (currentState) {
                case 'free':
                    if (closestAttractor && minDist < ATTRACTION_RADIUS) {
                        // Start being attracted
                        particleStates[particleIndex] = 'attracted';
                        particleCurrentAttractors[particleIndex] = closestAttractor;
                    }
                    break;

                case 'attracted':
                    if (!closestAttractor || closestAttractor !== currentAttractor) {
                        // Lost the attractor
                        particleStates[particleIndex] = 'free';
                        particleCurrentAttractors[particleIndex] = null;
                        particleCaptureTimes[particleIndex] = 0;
                    } else if (minDist < CAPTURE_RADIUS) {
                        // Close enough to be captured
                        particleStates[particleIndex] = 'captured';
                        particleCaptureTimes[particleIndex] = 0;
                    }
                    break;

                case 'captured':
                    particleCaptureTimes[particleIndex] += 0.016; // ~60fps
                    
                    if (!closestAttractor || closestAttractor !== currentAttractor) {
                        // Lost the attractor while captured
                        particleStates[particleIndex] = 'repelling';
                    } else if (particleCaptureTimes[particleIndex] >= MAX_CAPTURE_TIME) {
                        // Captured long enough, now repel
                        particleStates[particleIndex] = 'repelling';
                    }
                    break;

                case 'repelling':
                    // Continue repelling for a short time, then return to free state
                    particleCaptureTimes[particleIndex] += 0.016;
                    if (particleCaptureTimes[particleIndex] >= MAX_CAPTURE_TIME + 0.5) { // Repel for 0.5 seconds
                        particleStates[particleIndex] = 'free';
                        particleCurrentAttractors[particleIndex] = null;
                        particleCaptureTimes[particleIndex] = 0;
                    }
                    break;
            }

            // Apply forces based on current state
            if (currentAttractor) {
                const d = particlePos.distanceTo(currentAttractor.position);
                
                switch (currentState) {
                    case 'attracted':
                        // Strong attraction toward the attractor
                        const desired = new THREE.Vector3().subVectors(currentAttractor.position, particlePos);
                        desired.normalize();
                        // Stronger attraction when farther away
                        const attractionStrength = currentAttractor.currentStrength * (1 - d / ATTRACTION_RADIUS);
                        desired.multiplyScalar(attractionStrength);
                        particleAccelerations[particleIndex].add(desired);
                        break;

                    case 'captured':
                        // Gentle holding force - slow down and stay near the attractor
                        const holdForce = new THREE.Vector3().subVectors(currentAttractor.position, particlePos);
                        holdForce.normalize();
                        holdForce.multiplyScalar(0.1 * (d - CAPTURE_RADIUS * 0.5)); // Try to maintain position at half capture radius
                        particleAccelerations[particleIndex].add(holdForce);
                        
                        // Slow down velocity while captured
                        particleVelocities[particleIndex].multiplyScalar(0.95);
                        break;

                    case 'repelling':
                        // Strong repulsion away from the attractor
                        const repulsion = new THREE.Vector3().subVectors(particlePos, currentAttractor.position);
                        repulsion.normalize();
                        // Strong repulsion that decreases with distance
                        const repulsionStrength = currentAttractor.repulsionStrength * (1 - d / ATTRACTION_RADIUS);
                        repulsion.multiplyScalar(repulsionStrength);
                        particleAccelerations[particleIndex].add(repulsion);
                        break;
                }
            }

            return closestAttractor;
        }

        // Flocking behavior functions (only apply when free)
        function align(particleIndex, perceptionRadius = 3) {
            if (particleStates[particleIndex] !== 'free') return new THREE.Vector3();

            const position = particles.geometry.attributes.position;
            const i3 = particleIndex * 3;
            const x = position.array[i3];
            const y = position.array[i3 + 1];

            const steering = new THREE.Vector3();
            let total = 0;

            const range = { x: x, y: y, radius: perceptionRadius };
            const nearbyPoints = quadTree.query(range);

            for (const point of nearbyPoints) {
                if (point.index !== particleIndex && particleStates[point.index] === 'free') {
                    steering.add(particleVelocities[point.index]);
                    total++;
                }
            }

            if (total > 0) {
                steering.divideScalar(total);
                steering.setLength(0.07);
                steering.sub(particleVelocities[particleIndex]);
                steering.clampLength(0, 0.002);
            }

            return steering;
        }

        function separation(particleIndex, perceptionRadius = 3) {
            const position = particles.geometry.attributes.position;
            const i3 = particleIndex * 3;
            const x = position.array[i3];
            const y = position.array[i3 + 1];

            const steering = new THREE.Vector3();
            let total = 0;

            const range = { x: x, y: y, radius: perceptionRadius };
            const nearbyPoints = quadTree.query(range);

            for (const point of nearbyPoints) {
                if (point.index !== particleIndex) {
                    const otherI3 = point.index * 3;
                    const otherX = position.array[otherI3];
                    const otherY = position.array[otherI3 + 1];

                    const diff = new THREE.Vector3(x - otherX, y - otherY, 0);
                    const d = diff.length();

                    if (d > 0) {
                        diff.divideScalar(d * d);
                        steering.add(diff);
                        total++;
                    }
                }
            }

            if (total > 0) {
                steering.divideScalar(total);
                steering.setLength(0.07);
                steering.sub(particleVelocities[particleIndex]);
                steering.clampLength(0, 0.002);
            }

            return steering;
        }

        function cohesion(particleIndex, perceptionRadius = 5) {
            if (particleStates[particleIndex] !== 'free') return new THREE.Vector3();

            const position = particles.geometry.attributes.position;
            const i3 = particleIndex * 3;
            const x = position.array[i3];
            const y = position.array[i3 + 1];

            const steering = new THREE.Vector3();
            let total = 0;

            const range = { x: x, y: y, radius: perceptionRadius };
            const nearbyPoints = quadTree.query(range);

            for (const point of nearbyPoints) {
                if (point.index !== particleIndex && particleStates[point.index] === 'free') {
                    const otherI3 = point.index * 3;
                    const otherX = position.array[otherI3];
                    const otherY = position.array[otherI3 + 1];

                    steering.add(new THREE.Vector3(otherX, otherY, 0));
                    total++;
                }
            }

            if (total > 0) {
                steering.divideScalar(total);
                steering.sub(new THREE.Vector3(x, y, 0));
                steering.setLength(0.07);
                steering.sub(particleVelocities[particleIndex]);
                steering.clampLength(0, 0.002);
            }

            return steering;
        }

        function updateColor(particleIndex, currentAttractor) {
            const colors = particles.geometry.attributes.color;
            const i3 = particleIndex * 3;

            let targetColor = particleOriginalColors[particleIndex];

            if (currentAttractor) {
                let intensity = 0;
                const state = particleStates[particleIndex];
                
                if (state === 'attracted') {
                    intensity = 0.6; // Medium intensity when being attracted
                } else if (state === 'captured') {
                    intensity = 1.0; // Full intensity when captured
                } else if (state === 'repelling') {
                    intensity = 0.8; // Slightly less intensity when repelling
                }
                
                targetColor = particleOriginalColors[particleIndex].clone().lerp(
                    currentAttractor.influenceColor, 
                    intensity
                );
            }

            // Smooth color transition
            particleCurrentColors[particleIndex].lerp(targetColor, 0.1);
            
            colors.array[i3] = particleCurrentColors[particleIndex].r;
            colors.array[i3 + 1] = particleCurrentColors[particleIndex].g;
            colors.array[i3 + 2] = particleCurrentColors[particleIndex].b;
        }

        function edges(particleIndex) {
            const position = particles.geometry.attributes.position;
            const i3 = particleIndex * 3;
            let x = position.array[i3];
            let y = position.array[i3 + 1];

            if (x > WORLD_BOUNDS) {
                position.array[i3] = -WORLD_BOUNDS;
            } else if (x < -WORLD_BOUNDS) {
                position.array[i3] = WORLD_BOUNDS;
            }

            if (y > WORLD_BOUNDS) {
                position.array[i3 + 1] = -WORLD_BOUNDS;
            } else if (y < -WORLD_BOUNDS) {
                position.array[i3 + 1] = WORLD_BOUNDS;
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            const deltaTime = time - lastTime;
            lastTime = time;

            // Update attractors
            for (let i = 0; i < attractors.length; i++) {
                const attractor = attractors[i];
                attractor.pulsePhase += FORCE_PULSE_SPEED;
                attractor.currentStrength = attractor.baseStrength * (0.8 + 0.2 * Math.sin(attractor.pulsePhase));
                
                const ring = attractorMeshes[i];
                const scale = 0.8 + 0.2 * Math.sin(attractor.pulsePhase);
                ring.scale.set(scale, scale, scale);
            }

            // Clear and rebuild QuadTree
            quadTree.clear();
            const position = particles.geometry.attributes.position;
            for (let i = 0; i < controls.numParticles; i++) {
                const i3 = i * 3;
                quadTree.insert({
                    x: position.array[i3],
                    y: position.array[i3 + 1],
                    index: i
                });
            }

            // Update particles
            for (let i = 0; i < controls.numParticles; i++) {
                // Reset acceleration
                particleAccelerations[i].set(0, 0, 0);

                // Handle attraction first (this sets the state and applies attraction/capture/repulsion forces)
                const currentAttractor = handleAttraction(i);

                // Only apply flocking behaviors when particle is free
                if (particleStates[i] === 'free') {
                    const alignment = align(i).multiplyScalar(controls.align);
                    const cohesionForce = cohesion(i).multiplyScalar(controls.cohesion);
                    const separationForce = separation(i).multiplyScalar(controls.separation);

                    particleAccelerations[i].add(alignment);
                    particleAccelerations[i].add(cohesionForce);
                    particleAccelerations[i].add(separationForce);
                }

                // Update velocity and position
                particleVelocities[i].add(particleAccelerations[i]);
                
                // Limit speed based on state
                let maxSpeed = 0.07;
                if (particleStates[i] === 'captured') {
                    maxSpeed = 0.02; // Very slow when captured
                } else if (particleStates[i] === 'repelling') {
                    maxSpeed = 0.1; // Faster when repelling
                }
                particleVelocities[i].clampLength(0, maxSpeed);

                const i3 = i * 3;
                position.array[i3] += particleVelocities[i].x;
                position.array[i3 + 1] += particleVelocities[i].y;

                // Handle edges
                edges(i);

                // Update color based on current attractor and state
                updateColor(i, currentAttractor);
            }

            // Update trace
            updateTrace();

            // Mark attributes as needing update
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            // Render
            composer.render();
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // Fullscreen toggle
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'f' || event.key === 'F') {
                toggleFullScreen();
            }
            if (event.key === 's' || event.key === 'S') {
                renderer.domElement.toBlob(function(blob) {
                    const a = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    a.href = url;
                    const now = new Date();
                    const timestamp = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
                    a.download = `emotion_${timestamp}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }
        });

        // UI Controls
        document.getElementById('alignSlider').addEventListener('input', function(e) {
            controls.align = parseFloat(e.target.value);
            document.getElementById('alignValue').textContent = controls.align.toFixed(1);
        });

        document.getElementById('cohesionSlider').addEventListener('input', function(e) {
            controls.cohesion = parseFloat(e.target.value);
            document.getElementById('cohesionValue').textContent = controls.cohesion.toFixed(1);
        });

        document.getElementById('separationSlider').addEventListener('input', function(e) {
            controls.separation = parseFloat(e.target.value);
            document.getElementById('separationValue').textContent = controls.separation.toFixed(1);
        });

        document.getElementById('traceToggle').addEventListener('click', function() {
            controls.trace = !controls.trace;
            this.textContent = `Trace: ${controls.trace ? 'ON' : 'OFF'}`;
            
            if (!controls.trace) {
                clearTrace();
            }
        });

        document.getElementById('resetButton').addEventListener('click', function() {
            // Reset particles to initial state
            for (let i = 0; i < controls.numParticles; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * WORLD_BOUNDS * 2;
                particlePositions[i3 + 1] = (Math.random() - 0.5) * WORLD_BOUNDS * 2;
                particlePositions[i3 + 2] = 0;

                const colorIndex = Math.floor(Math.random() * palette.length);
                const originalColor = palette[colorIndex];
                particleColors[i3] = originalColor.r;
                particleColors[i3 + 1] = originalColor.g;
                particleColors[i3 + 2] = originalColor.b;

                particleOriginalColors[i] = originalColor.clone();
                particleCurrentColors[i] = originalColor.clone();
                
                particleStates[i] = 'free';
                particleCaptureTimes[i] = 0;
                particleCurrentAttractors[i] = null;

                particleVelocities[i].set(
                    (Math.random() - 0.5) * 0.07,
                    (Math.random() - 0.5) * 0.07,
                    0
                );

                particleAccelerations[i].set(0, 0, 0);
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            // Reset attractors
            for (let i = 0; i < attractors.length; i++) {
                attractors[i].position.set(
                    (Math.random() - 0.5) * WORLD_BOUNDS * 1.5,
                    (Math.random() - 0.5) * WORLD_BOUNDS * 1.5,
                    0
                );
                attractorMeshes[i].position.copy(attractors[i].position);
            }

            clearTrace();
        });

        // Start animation
        animate(0);
    </script>
</body>
</html>