<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Hopf Fibration Visualization with Threejs">
    <meta name="keywords" content="Mathematics, Hopf, Fibration, Stereographic, Projection, Threejs">
    <meta name="author" content="Juan Carlos Ponce Campuzano">
    <title>Hopf Fibration Visualization</title>

    <link rel="icon" type="image/png" href="../../images/icon/infinity32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../images/icon/infinity16.png" sizes="16x16">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JPYTNF6MB4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-JPYTNF6MB4');
    </script>


    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #0b1020;
        }

        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        .hud {
            position: fixed;
            left: 16px;
            top: 16px;
            color: #eaf2ff;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
            font-size: 14px;
            line-height: 1.3;
        }

        .hint {
            opacity: .8;
            max-width: 340px;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            background: #1b2a4a;
            border: 1px solid #2b3a5a;
            margin-right: 8px;
            font-size: 12px;
        }

        .footer {
            position: fixed;
            right: 16px;
            bottom: 16px;
            color: #adbff5;
            font-size: 0.95rem;
            opacity: .7;
        }

        .controls {
            position: fixed;
            left: 16px;
            bottom: 54px;
            background: rgba(11, 16, 32, 0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            color: #eaf2ff;
            font-family: ui-sans-serif, system-ui;
            width: 200px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .controls.hidden {
            transform: translateY(calc(100% + 20px));
            opacity: 0;
            pointer-events: none;
        }

        .controls h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #b4d0ff;
        }

        .controls button {
            width: 100%;
            padding: 8px;
            background: #2b4a8a;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 5px;
            transition: background 0.3s;
        }

        .controls button:hover {
            background: #3a5aaa;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #1b2a4a;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: #4a72da;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #2b4a8a;
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .instructions {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 10px;
            padding-top: 1px;
            padding-bottom: 1px;
            background: rgba(27, 42, 74, 0.5);
            border-radius: 8px;
            font-size: 14px;
        }

        .selection-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3366;
            border: 2px solid white;
            box-shadow: 0 0 8px rgba(255, 51, 102, 0.8);
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 100;
            display: none;
        }

        .dropdown {
            width: 100%;
            padding: 6px;
            margin-top: 2px;
            margin-bottom: 10px;
            background: #1b2a4a;
            color: #eaf2ff;
            border: 1px solid #2b3a5a;
            border-radius: 4px;
            font-family: ui-sans-serif, system-ui;
        }

        .dropdown option {
            background: #0b1020;
        }

        .toggle-controls-btn {
            position: fixed;
            left: 16px;
            bottom: 16px;
            background: #2b4a8a;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-family: ui-sans-serif, system-ui;
            font-size: 12px;
            z-index: 1000;
        }

        .toggle-controls-btn:hover {
            background: #3a5aaa;
        }

        .key-shortcut {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 4px;
            font-family: monospace;
        }

        .info-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(11, 16, 32, 0.95);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            z-index: 1001;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            color: #eaf2ff;
            font-family: ui-sans-serif, system-ui;
            min-width: 300px;
            display: none;
            /* Responsive width */
            width: clamp(300px, 80%, 740px);
            max-height: 80vh;
            /* Enable scrolling */
            overflow-y: auto;
            overflow-x: hidden;
            font-size: 1.1rem;
        }

        .info-modal .matheqn {
            margin-top: -0.5rem;
            margin-bottom: 1rem;
            overflow-y: hidden;
            overflow-x: auto;
        }

        .info-modal h1,
        h2,
        h3 {
            margin-top: 0;
            color: #b4d0ff;
        }

        .info-modal .section {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .info-modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #1b2a4a;
            color: #eaf2ff;
            border: 1px solid #2b3a5a;
            border-radius: 4px;
            font-family: ui-sans-serif, system-ui;
        }

        .info-modal button {
            padding: 8px 16px;
            background: #2b4a8a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 1rem;
        }

        .info-modal button:hover {
            background: #3a5aaa;
        }

        .info-modal a {
            color: #50abd5;
        }

        .info-modal a:hover {
            color: #a79ec3;
        }

        hr {
            border: 1px solid #aebcd5;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
        }

        #small-screen-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background: #0b1020;
            color: #eaf2ff;
            display: flex;
            justify-content: center;
            /* horizontal center */
            align-items: center;
            /* vertical center */
            text-align: center;
            padding: 1rem;
            z-index: 2000;
            font-family: ui-sans-serif, system-ui, sans-serif;
        }

        #small-screen-message .message-box {
            max-width: 13rem;
            background: rgba(27, 42, 74, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0b1020;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            color: #eaf2ff;
            font-family: ui-sans-serif, system-ui, sans-serif;
            flex-direction: column;
        }

        .loader-content {
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #4a72da;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>

    <!--MathJax starts-->
    <script>
        window.MathJax = {
            tex: {
                tags: "ams",
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <!--MathJax Ends-->

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.179.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.179.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
    <div id="app"></div>
    <div class="selection-marker" id="selection-marker"></div>

    <div id="loader">
        <div class="loader-content">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>
    </div>

    <div id="small-screen-message">
        <div class="message-box">
            <h2>Screen Too Small</h2>
            <p>
                For the best experience, use this app on a device with a larger screen height.
            </p>

            <picture>
                <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f636_200d_1f32b_fe0f/512.webp"
                    type="image/webp">
                <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f636_200d_1f32b_fe0f/512.gif" alt="😶"
                    width="64" height="64">
            </picture>
        </div>
    </div>


    <button class="toggle-controls-btn" id="toggle-controls-btn">▼ Hide Controls</button>
    <div class="controls" id="controls">
        <h3>Hopf Fibration Controls</h3>
        <div class="instructions">
            <p>
                <strong>Instructions:</strong>
                Move mouse over sphere to select point,
                then press <span class="key-shortcut">A</span>
                to add a Hopf fiber at that location.
            </p>
            <!--<p> Press <span class="key-shortcut">S</span> to save view.</p>-->
        </div>
        <div class="toggle-container">
            <span>Fibers</span>
            <label class="toggle">
                <input type="checkbox" id="toggle-fibers" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-container">
            <span>Sphere</span>
            <label class="toggle">
                <input type="checkbox" id="toggle-sphere" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-container">
            <span>Points</span>
            <label class="toggle">
                <input type="checkbox" id="toggle-points" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-container">
            <span>Axes</span>
            <label class="toggle">
                <input type="checkbox" id="toggle-axes" unchecked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-container">
            <span>Grid</span>
            <label class="toggle">
                <input type="checkbox" id="toggle-grid" unchecked>
                <span class="slider"></span>
            </label>
        </div>
        <select class="dropdown" id="examples">
            <option value="custom">Custom Points</option>
            <option value="icosahedral">Icosahedral Pattern</option>
            <option value="spiral">Spiral Pattern</option>
            <option value="latitude-bands">Latitude Bands</option>
            <option value="longitude-bands">Longitude Bands</option>
            <option value="equator-sine">Equator sine</option>
        </select>
        <button id="clear-btn">Clear All Fibers</button>
        <button id="save-view-btn">Save View</button>
        <button id="share-link-btn">Share Scene</button>
        <button id="modal-btn">What is this?</button>

    </div>
    <div class="footer">Hopf fibration via stereographic projection from S³ → ℝ³</div>

    <!-- Share Modal -->
    <div class="modal-overlay" id="info-modal-overlay"></div>
    <div class="info-modal" id="info-modal">

        <h1>Hopf Fibration Visualization</h1>
        <hr>

        <div class="section">
            <h2>What is a Hopf fibration?</h2>
            <div class="math">
                <p>
                    The <strong>Hopf fibration</strong> is a fundamental construction in topology that gives a
                    surprising way of
                    decomposing higher-dimensional spheres. Formally, it is a continuous map from the 3-sphere to the
                    2-sphere:
                </p>
                <p style="text-align: center;">
                    \( h: S^3 \to S^2 \)
                </p>
                <p>
                    with the remarkable property that the preimage \( h^{-1}(p) \) of every point \( p \in S^2 \) is a
                    circle
                    \( S^1 \). In other words, \(S^3\) can be written as a disjoint union of circles (called
                    <em>fibers</em>), one for each point on the ordinary 2-sphere.
                </p>

                <h3>Why is it important?</h3>
                <p>
                    The Hopf fibration is not just a mathematical curiosity; it plays a central role in both mathematics
                    and physics:
                </p>
                <ul style="line-height: 25px;">
                    <li>
                        <strong>In Mathematics:</strong> It was the first known example of a <strong>non-trivial fiber
                            bundle</strong>,
                        showing that spaces can be “twisted together” in globally non-obvious ways
                        (since \( S^3 \not\cong S^2 \times S^1 \)). It is a key example in homotopy theory, differential
                        geometry,
                        and the study of characteristic classes.
                    </li>
                    <li>
                        <strong>In Physics:</strong> The fibration provides geometric insight into physical systems:
                        <ul>
                            <li><strong>Quantum Mechanics:</strong> The state space of a pure qubit is the 3-sphere \(
                                S^3 \).
                                The Hopf map projects this space onto the Bloch sphere \( S^2 \), which represents
                                observable states.</li>
                            <li><strong>Field Theory & Optics:</strong> It models the topology of magnetic fields
                                (e.g. Dirac monopoles, Hopfions) and describes structured light beams whose
                                polarization is linked to spatial geometry.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    In essence, the Hopf fibration builds a bridge between abstract topology and the geometry of our
                    physical world.
                </p>

                <p>
                    <b>Note:</b> This project was inspired by Richard Behiel's video
                    <a href="https://youtu.be/dkyvZo68IoM" target="_blank">A Quick Intro to Fiber Bundles (Hopf
                        Fibration)</a>.
                    For further reading, see <a
                        href="https://nilesjohnson.net/hopf-articles/Treisman_Guide-to-Hopf-fibration.pdf"
                        target="_blank">Zachary Treisman's notes</a>.
                    Also
                    check Thijs' GeoGebra applet:
                    <a href="https://www.geogebra.org/m/f2suuzct" target="_blank">Hopf fibration</a>.
                </p>
            </div>
        </div>

        <hr>

        <div class="section">
            <h2>How this project works?</h2>
            <div class="math">
                <p>
                    To make the Hopf fibration visible, the fibers are turned into 3D geometry and displayed with
                    <a href="https://threejs.org/" target="_blank">Three.js</a>.
                    The library handles real-time rendering, lighting, and shading,
                    leaving the focus on the underlying geometry.
                    In this way, abstract mathematics becomes something
                    you can explore visually and intuitively.
                </p>
                <p>
                    The visualization follows these steps:
                </p>
                <ol style="line-height: 25px;">
                    <li>Sample directions \(n \in S^2\).</li>
                    <li>Convert each direction into a spinor \((z_1, z_2)\).</li>
                    <li>Generate points along the fiber by rotating the phase \(\theta \in [0, 2\pi)\).</li>
                    <li>Apply stereographic projection \(S^3 \to \mathbb{R}^3\).</li>
                    <li>Render the fibers using Three.js.</li>
                </ol>

                <h2>Terminology</h2>
                <h3>The 3-Sphere \(S^3\)</h3>
                <p>
                    The 3-sphere is defined by
                    \[
                    S^3 = \{ (x_1, x_2, x_3, x_4) \in \mathbb{R}^4 \mid x_1^2 + x_2^2 + x_3^2 + x_4^2 = 1 \}.
                    \]
                    It can also be expressed in complex coordinates \((z_1, z_2) \in \mathbb{C}^2\) with
                    \[
                    z_1 = x_1 + i x_2, \quad z_2 = x_3 + i x_4, \quad |z_1|^2 + |z_2|^2 = 1.
                    \]
                </p>

                <h3>Spinor Representation</h3>
                <p>
                    Given a point \(n = (x,y,z)\) on \(S^2\), a corresponding spinor is
                    \[
                    z_1 = \sqrt{\tfrac{1+n_z}{2}}, \quad
                    z_2 = \frac{x + i y}{2 z_1}.
                    \]
                    This representation is convenient for generating Hopf fibers.
                </p>

                <h3>Hopf Fiber Parametrization</h3>
                <p>
                    A fiber associated to \((z_1, z_2)\) is
                    \[
                    (z_1 e^{i \theta},\, z_2 e^{i \theta}), \quad \theta \in [0, 2\pi).
                    \]
                    After stereographic projection to \(\mathbb{R}^3\), the points are
                    \[
                    \mathbf{p} = \left( \tfrac{x_1}{1 - x_4},\, \tfrac{x_2}{1 - x_4},\, \tfrac{x_3}{1 - x_4} \right).
                    \]
                </p>

                <h3>Stereographic Projection</h3>
                <p>
                    Stereographic projection from \(S^3 \subset \mathbb{R}^4\) (excluding the north pole
                    \(N=(0,0,0,1)\)) to \(\mathbb{R}^3\) is
                    \[
                    \pi(x_1, x_2, x_3, x_4) =
                    \left( \frac{x_1}{1 - x_4},\, \frac{x_2}{1 - x_4},\, \frac{x_3}{1 - x_4} \right).
                    \]
                    Under this map, Hopf fibers remain circles in \(\mathbb{R}^3\).
                </p>
            </div>
        </div>

        <div class="section">
            <h2>Patterns and Examples</h2>
            <div class="math">
                Some point distributions used for visualizations include:
                <ul style="line-height: 25px;">
                    <li><b>Icosahedral:</b> points at the vertices of an icosahedron projected onto \(S^2\).</li>
                    <li><b>Spiral:</b> points arranged from the north to south pole.</li>
                    <li><b>Latitude bands:</b> points along the equator and tropics of \(S^2\).</li>
                    <li><b>Longitude bands:</b> points along meridians of \(S^2\).</li>
                    <li><b>Equator sine:</b> points on a wavy curve along the equator of \(S^2\).</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>That's it!</h2>
            <div class="math">
                I hope this visualization helps you explore the Hopf
                fibration in a more intuitive way.
                This project exists thanks to the support of my Patrons.
                If you want to join them to support
                my work, you can do it with the link below:
            </div>
        </div>

        <br />

        <div style="text-align: center;">
            <button onClick="window.open('https://www.patreon.com/jcponce', '_blank')">❤️ Support</button>
            <button id="close-modal">❌ Close</button>
            <p>\(\Large\infty\)</p>
            <br />
        </div>
    </div>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const container = document.getElementById('app');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0b1020, 0.015);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 200);
        // Rotate the camera to have z-axis as top view
        camera.position.set(2.5, 4, 1.5); // Position camera above the sphere looking down
        camera.up.set(0, 0, 1); // Set Z as the up direction

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 2.5);
        dir.position.set(4, 4, 8);
        scene.add(dir);

        const grid = new THREE.GridHelper(20, 20, 0xa7b9e5, 0x1c2c4f);
        grid.material.opacity = 0.84;
        grid.material.transparent = true;
        grid.rotation.x = Math.PI / 2; // Rotate grid to be horizontal (XY plane)
        scene.add(grid);
        grid.visible = false;

        const axesHelper = new THREE.AxesHelper(1);
        scene.add(axesHelper);
        axesHelper.visible = false;

        // Create the main sphere in the center of the scene
        const sphereGeo = new THREE.SphereGeometry(1, 48, 32);
        const sphereMat = new THREE.MeshStandardMaterial({
            color: 0x22409a,
            roughness: 0.35,
            metalness: 0.1,
            transparent: true,
            opacity: 0.65,
            emissive: 0x07142e,
            emissiveIntensity: 0.2,
            side: THREE.DoubleSide
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(sphere);

        const pickMarkers = new THREE.Group();
        scene.add(pickMarkers);
        const markerGeo = new THREE.SphereGeometry(0.035, 16, 16);
        const markerMat = new THREE.MeshStandardMaterial({ color: 0xb4d0ff, emissive: 0x224488, emissiveIntensity: 0.5 });

        // Parameters for the Hopf fibration
        const params = {
            waves: 4,
            amplitude: 0.25,
            segments: 240
        };

        // Set up toggle functionality
        const toggleFibers = document.getElementById('toggle-fibers');
        toggleFibers.addEventListener('change', function () {
            fibers.visible = this.checked;
        });

        let sphereVisible = true;
        const toggleSphere = document.getElementById('toggle-sphere');
        toggleSphere.addEventListener('change', function () {
            sphere.visible = this.checked;
            sphereVisible = this.checked;  // track state
            if (!sphereVisible) {
                // Hide marker when sphere is off
                selectionMarker.style.display = 'none';
                selectedPoint = null;
            }
        });

        const togglePoints = document.getElementById('toggle-points');
        togglePoints.addEventListener('change', function () {
            pickMarkers.visible = this.checked;
        });

        const toggleAxes = document.getElementById('toggle-axes');
        toggleAxes.addEventListener('change', function () {
            axesHelper.visible = this.checked;
        });

        const toggleGrid = document.getElementById('toggle-grid');
        toggleGrid.addEventListener('change', function () {
            grid.visible = this.checked;
        });

        document.getElementById('clear-btn').addEventListener('click', clearFibers);

        // Set up examples dropdown
        const examplesDropdown = document.getElementById('examples');
        examplesDropdown.addEventListener('change', function () {
            if (this.value !== 'custom') {
                loadExample(this.value);
            }
        });

        function saveCurrentView() {
            // Render one more frame to ensure the canvas is up-to-date
            renderer.render(scene, camera);

            // Get image data from canvas
            const dataURL = renderer.domElement.toDataURL("image/png");

            // Create a temporary download link
            const link = document.createElement("a");
            link.href = dataURL;

            // Name with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
            link.download = `hopf_view_${timestamp}.png`;

            // Trigger download
            link.click();
        }

        // Hook the button to the function
        document.getElementById("save-view-btn").addEventListener("click", saveCurrentView);

        // Add a "Share Scene" button under Save View
        const shareBtn = document.getElementById("share-link-btn");

        shareBtn.addEventListener("click", () => {
            const state = {
                fibers: pickMarkers.children.map(m => m.position.clone().normalize().toArray()),
                toggles: {
                    fibers: toggleFibers.checked,
                    sphere: toggleSphere.checked,
                    points: togglePoints.checked,
                    axes: toggleAxes.checked,
                    grid: toggleGrid.checked,
                },
                example: examplesDropdown.value
            };

            // Encode state
            const json = JSON.stringify(state);
            const encoded = btoa(json); // base64
            const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

            // Copy to clipboard
            navigator.clipboard.writeText(url).then(() => {
                alert("Shareable link copied to clipboard!");
            });
        });

        // On load, check if URL has state
        window.addEventListener("load", () => {
            if (window.location.hash.length > 1) {
                try {
                    const encoded = window.location.hash.slice(1);
                    const json = atob(encoded);
                    const state = JSON.parse(json);

                    // Restore example
                    examplesDropdown.value = state.example;
                    if (state.example !== "custom") loadExample(state.example);

                    // Restore toggles
                    toggleFibers.checked = state.toggles.fibers; fibers.visible = state.toggles.fibers;
                    toggleSphere.checked = state.toggles.sphere; sphere.visible = state.toggles.sphere;
                    togglePoints.checked = state.toggles.points; pickMarkers.visible = state.toggles.points;
                    toggleAxes.checked = state.toggles.axes; axesHelper.visible = state.toggles.axes;
                    toggleGrid.checked = state.toggles.grid; grid.visible = state.toggles.grid;

                    // Restore custom fibers
                    if (state.example === "custom") {
                        clearFibers();
                        state.fibers.forEach(arr => {
                            addFiber(new THREE.Vector3(...arr));
                        });
                    }
                } catch (err) {
                    console.error("Invalid state in URL:", err);
                }
            }
        });

        // Modal elements
        const modalBtn = document.getElementById("modal-btn");
        const modal = document.getElementById("info-modal");
        const overlay = document.getElementById("info-modal-overlay");
        const closeBtn = document.getElementById("close-modal");

        // Open modal
        modalBtn.addEventListener("click", () => {
            modal.style.display = "block";
            overlay.style.display = "block";
        });

        // Close modal (via button)
        closeBtn.addEventListener("click", () => {
            modal.style.display = "none";
            overlay.style.display = "none";
        });

        // Close modal (via overlay click)
        overlay.addEventListener("click", () => {
            modal.style.display = "none";
            overlay.style.display = "none";
        });

        // Optional: close with Escape key
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                modal.style.display = "none";
                overlay.style.display = "none";
            }
        });


        // Set up controls toggle
        const controlsElement = document.getElementById('controls');
        const toggleControlsBtn = document.getElementById('toggle-controls-btn');
        let controlsVisible = true;

        toggleControlsBtn.addEventListener('click', function () {
            controlsVisible = !controlsVisible;
            if (controlsVisible) {
                controlsElement.classList.remove('hidden');
                toggleControlsBtn.textContent = '▼ Hide Controls';
            } else {
                controlsElement.classList.add('hidden');
                toggleControlsBtn.textContent = '▲ Controls';
            }
        });

        function spinorFromN(n) {
            const nz = n.z;
            const denom = 2 * Math.sqrt((1 + nz) / 2);
            if (denom > 1e-8) {
                const z1 = { re: Math.sqrt((1 + nz) / 2), im: 0 };
                const z2 = { re: n.x / denom, im: n.y / denom };
                return { z1, z2 };
            } else {
                return { z1: { re: 0, im: 0 }, z2: { re: 0, im: 1 } };
            }
        }

        function rotatePhase(z, theta) {
            const c = Math.cos(theta), s = Math.sin(theta);
            return { re: z.re * c - z.im * s, im: z.re * s + z.im * c };
        }

        function stereoProjectS3ToR3(x1, x2, x3, x4) {
            const d = 1 - x4;
            const inv = 1 / d;
            return new THREE.Vector3(x1 * inv, x2 * inv, x3 * inv);
        }

        function hopfFiberPoints(n, segments) {
            const { z1, z2 } = spinorFromN(n);
            const pts = [];
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const theta = t * Math.PI * 2;
                const z1t = rotatePhase(z1, theta);
                const z2t = rotatePhase(z2, theta);
                const p = stereoProjectS3ToR3(z1t.re, z1t.im, z2t.re, z2t.im);
                pts.push(p);
            }
            return pts;
        }

        const fibers = new THREE.Group();
        scene.add(fibers);

        function clearFibers() {
            // Remove all fibers
            while (fibers.children.length > 0) {
                const fiber = fibers.children[0];
                fiber.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                fibers.remove(fiber);
            }

            // Remove all markers
            while (pickMarkers.children.length > 0) {
                const marker = pickMarkers.children[0];
                if (marker.geometry) marker.geometry.dispose();
                if (marker.material) marker.material.dispose();
                pickMarkers.remove(marker);
            }

            // Reset dropdown to custom
            examplesDropdown.value = 'custom';
        }

        function addFiber(n) {
            const segments = params.segments;
            const pts = hopfFiberPoints(n, segments);

            // Make a smooth curve from Hopf fiber points
            const curve = new THREE.CatmullRomCurve3(pts, true); // true = closed loop
            const tubeGeo = new THREE.TubeGeometry(
                curve,
                segments * 2,       // tubular segments
                0.02,               // radius (thickness of fiber)
                12,                 // radial segments
                true                // closed tube
            );
            const tubeMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0.4 + 0.8 * Math.random(), 0.9, 0.5),
                roughness: 0.3,
                metalness: 0.2,
                emissive: 0x113355,
                emissiveIntensity: 0.5
            });

            const tube = new THREE.Mesh(tubeGeo, tubeMat);
            fibers.add(tube);

            // Keep your marker
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(n.clone().multiplyScalar(1.001));
            pickMarkers.add(marker);
        }


        function loadExample(exampleName) {
            clearFibers();

            if (exampleName === 'latitude-bands') {
                const bands = 6;   // number of latitude circles
                const perBand = 80; // points per circle

                for (let b = 1; b < bands; b++) {
                    const phi = (b / bands) * Math.PI - Math.PI / 2; // from -90° to +90°
                    const z = Math.sin(phi);
                    const r = Math.cos(phi);

                    for (let i = 0; i < perBand; i++) {
                        const theta = (i / perBand) * Math.PI + Math.PI - Math.PI * 0.45;
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        addFiber(new THREE.Vector3(x, y, z).normalize());
                    }
                }
            } else if (exampleName === 'spiral') {
                // Spiral pattern - points along a spiral on the sphere
                const numPoints = 100;
                for (let i = 0; i < numPoints; i++) {
                    const t = i / numPoints;
                    const theta = t * Math.PI * 4; // Multiple rotations
                    const phi = Math.acos(1 - 2 * t); // From north to south pole

                    const x = Math.sin(phi) * Math.cos(theta);
                    const y = Math.sin(phi) * Math.sin(theta);
                    const z = Math.cos(phi);

                    addFiber(new THREE.Vector3(x, y, z).normalize());
                }
            } else if (exampleName === 'icosahedral') {
                const phi = (1 + Math.sqrt(5)) / 2; // golden ratio
                const vertices = [
                    [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
                    [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
                    [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
                ];
                for (let v of vertices) {
                    const n = new THREE.Vector3(v[0], v[1], v[2]).normalize();
                    addFiber(n);
                }
            } else if (exampleName === 'longitude-bands') {
                const bands = 4;   // number of longitude slices
                const perBand = 40; // points along each slice

                for (let b = 0; b < bands; b++) {
                    const theta = (b / bands) * Math.PI * 2; // longitude angle
                    const cosTheta = Math.cos(theta);
                    const sinTheta = Math.sin(theta);

                    for (let i = 0; i < perBand; i++) {
                        const phi = (i / (perBand - 1) + Math.PI / 8) * Math.PI / 2; // latitude from north to south pole
                        const x = Math.sin(phi) * cosTheta;
                        const y = Math.sin(phi) * sinTheta;
                        const z = Math.cos(phi);
                        addFiber(new THREE.Vector3(x, y, z).normalize());
                    }
                }
            } else if (exampleName === 'equator-sine') {
                // Sinusoidal closed curve along the equator
                const numPoints = 200;   // resolution
                const amplitude = 0.3;   // how far the sine goes up/down
                const frequency = 5;     // number of oscillations around the equator

                for (let i = 0; i < numPoints; i++) {
                    const t = (i / numPoints) * Math.PI * 2; // go around once
                    const x = Math.cos(t);
                    const y = Math.sin(t);
                    const z = amplitude * Math.sin(frequency * t); // sinusoidal wiggle

                    addFiber(new THREE.Vector3(x, y, z).normalize());
                }
            }
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedPoint = null;
        const selectionMarker = document.getElementById('selection-marker');

        function onMouseMove(e) {
            if (!sphereVisible) {
                selectedPoint = null;
                selectionMarker.style.display = 'none';
                return; // don’t allow selection when sphere is off
            }

            // Normal raycasting logic
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hit = raycaster.intersectObject(sphere, false)[0];

            if (hit) {
                selectedPoint = hit.point.clone().normalize();

                // Project 3D point to screen coords
                const vector = selectedPoint.clone();
                vector.project(camera);

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;

                selectionMarker.style.left = `${x}px`;
                selectionMarker.style.top = `${y}px`;
                selectionMarker.style.display = 'block';
            } else {
                selectedPoint = null;
                selectionMarker.style.display = 'none';
            }
        }

        function onKeyDown(e) {
            // Add fiber when 'A' key is pressed
            if (e.key === 'a' || e.key === 'A') {
                if (selectedPoint) {
                    addFiber(selectedPoint);
                    examplesDropdown.value = 'custom';
                }
            }

            // Toggle controls with 'H' key
            if (e.key === 'h' || e.key === 'H') {
                toggleControlsBtn.click();
            }

            // Save current view with 'S' key
            if (e.key === 's' || e.key === 'S') {
                saveCurrentView();
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('keydown', onKeyDown);

        function checkScreenSize() {
            const msg = document.getElementById('small-screen-message');
            if (window.innerWidth < 410 || window.innerHeight < 610) {
                msg.style.display = 'flex';  // show overlay
            } else {
                msg.style.display = 'none';  // hide overlay
            }
        }

        // Run on load and when resizing
        window.addEventListener('load', checkScreenSize);
        window.addEventListener('resize', checkScreenSize);

        // Hide loader once everything is ready
        window.addEventListener("load", () => {
            const loader = document.getElementById("loader");
            loader.style.opacity = "0";
            loader.style.transition = "opacity 0.5s ease";
            setTimeout(() => loader.style.display = "none", 500);
        });


        function render() {
            controls.update();

            renderer.setClearColor(0x0b1020, 1);
            renderer.clear(true, true, true);
            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }
        render();

        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', onResize);

        // Add initial fibers
        addFiber(new THREE.Vector3(0, 0, 1));
        addFiber(new THREE.Vector3(1, 0, 0).normalize());
        addFiber(new THREE.Vector3(0, 1, 0).normalize());
    </script>
</body>

</html>