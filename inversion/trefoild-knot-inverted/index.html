<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trefoil Knot Inverted</title>
    <!--
  <link rel="stylesheet" href="./style.css">-->

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            overflow: hidden;
        }

        .webgl {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }
    </style>
</head>

<body>
    <canvas class="webgl"></canvas>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"
        crossorigin="anonymous"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.179.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.179.0/examples/jsm/"
      }
    }
  </script>
    <script type="module">

        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        // Shorthands
        const cos = Math.cos;
        const sin = Math.sin;
        const pow = Math.pow;
        const PI = Math.PI;

        function torusknotSurface(u, v, target, size, translate) {
            u = 4 * PI * u;
            v = 2 * PI * v;

            const XX = -size * (cos(u) * cos(v) + 3 * cos(u) * (1.5 + sin(1.5 * u) / 2)) + translate;
            const YY = size * (sin(u) * cos(v) + 3 * sin(u) * (1.5 + sin(1.5 * u) / 2));
            const ZZ = size * (sin(v) + 2 * cos(1.5 * u));

            const norm2 = pow(XX, 2) + pow(YY, 2) + pow(ZZ, 2);
            target.set(0.5 * XX / norm2, 0.5 * YY / norm2, 0.5 * ZZ / norm2);
        }

        function sphereSurface(u, v, target, r, uComponent, vComponent) {
            u = uComponent * u;
            v = vComponent * v;
            target.set(r * cos(u) * sin(v), r * sin(u) * sin(v), r * cos(v));
        }

        function trefoilknotSurface(u, v, target, uComponent, vComponent, size, tx, ty, tz) {
            u = uComponent * u;
            v = vComponent * v;

            const x = -size * (cos(u) * cos(v) + 3 * cos(u) * (1.5 + sin(1.5 * u) / 2)) + tx;
            const y = size * (sin(u) * cos(v) + 3 * sin(u) * (1.5 + sin(1.5 * u) / 2)) + ty;
            const z = size * (sin(v) + 2 * cos(1.5 * u)) + tz;
            target.set(x, y, z);
        }

        function createMaterials(options) {
            const textureLoader = new THREE.TextureLoader();
            const matcapTexture = textureLoader.load('../assets/textures/matcaps/3.png');

            return {
                matcapMaterial: new THREE.MeshMatcapMaterial({ matcap: matcapTexture, side: THREE.DoubleSide }),
                normalMaterial: new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }),
                phongMaterial: new THREE.MeshPhongMaterial({ color: options.color, shininess: 100, side: THREE.DoubleSide }),
                wireframeMaterial: new THREE.MeshBasicMaterial({ color: 0x1a1a1a, wireframe: true })
            };
        }

        function setupScene(canvas) {
            const scene = new THREE.Scene();

            // Camera
            const sizes = { width: window.innerWidth, height: window.innerHeight };
            const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);
            camera.position.set(1, 1, 3);
            scene.add(camera);

            // Renderer (white background, opaque)
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
            renderer.setSize(sizes.width, sizes.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0xf2f2f2, 1); // keep background always white

            // Controls
            const controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true;

            // Lights
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);
            scene.add(new THREE.AmbientLight(0x404040));

            // Resize
            window.addEventListener('resize', () => {
                sizes.width = window.innerWidth;
                sizes.height = window.innerHeight;
                camera.aspect = sizes.width / sizes.height;
                camera.updateProjectionMatrix();
                renderer.setSize(sizes.width, sizes.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            });

            return { scene, camera, renderer, controls };
        }

        // GUI setup
        const gui = new GUI();
        const options = {
            material: 'Matcap',
            mesh: false,
            size: 0.12,
            translate: 2.9,
            autoRotate: false,
            color: '#049ef4',      // Phong color (controller hidden unless Phong)
            knot: true,
            inversion: true,
            sphere: true
        };

        // Scene setup
        const canvas = document.querySelector('canvas.webgl');
        const { scene, camera, renderer, controls } = setupScene(canvas);

        // Materials
        const materials = createMaterials(options);

        // Geometry: inversion surface
        const meshRes = { x: 500, y: 100 };
        let geometry = new ParametricGeometry((u, v, target) =>
            torusknotSurface(u, v, target, options.size, options.translate), meshRes.x, meshRes.y);
        geometry.rotateX(Math.PI / 2);
        let mesh = new THREE.Mesh(geometry, materials.matcapMaterial);
        scene.add(mesh);

        // Geometry: trefoil knot
        let geometryKnot = new ParametricGeometry((u, v, target) =>
            trefoilknotSurface(u, v, target, 4 * PI, 2 * PI, options.size, options.translate, 0, 0), 64, 64);
        geometryKnot.rotateX(Math.PI / 2);
        let meshKnot = new THREE.Mesh(geometryKnot, new THREE.MeshPhongMaterial({
            color: '#00ffff',
            shininess: 200,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.5
        }));
        scene.add(meshKnot);

        // Geometry: sphere
        let geometrySphere = new ParametricGeometry((u, v, target) =>
            sphereSurface(u, v, target, 1, 2 * PI, PI), 18, 18);
        geometrySphere.rotateX(Math.PI / 2);

        let materialSphere = new THREE.MeshPhongMaterial({
            color: '#000',
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.15,
            wireframe: true
        });
        let meshSphere = new THREE.Mesh(geometrySphere, materialSphere);
        scene.add(meshSphere);

        const wireframeSphere = new THREE.LineSegments(
            new THREE.WireframeGeometry(geometrySphere),
            new THREE.LineBasicMaterial({ color: 0xbfbfbf })
        );
        scene.add(wireframeSphere);

        // Wireframe mesh for inversion
        let wireframeMesh = new THREE.Mesh(geometry, materials.wireframeMaterial);

        // Visibility defaults
        mesh.visible = options.inversion;
        meshKnot.visible = options.knot;
        meshSphere.visible = wireframeSphere.visible = options.sphere;

        // GUI
        function commonUI() {
            // Style selector
            const styleController = gui.add(options, 'material', ['Matcap', 'Normal', 'Phong']).name('Style');

            // Phong color controller (create once, hide/show as needed)
            const phongColorController = gui
                .addColor(options, 'color')
                .name('Phong Color')
                .onChange(v => {
                    materials.phongMaterial.color.set(v);
                });

            // Hide initially unless Phong is already selected
            if (options.material !== 'Phong') phongColorController.hide();

            // React to style change
            styleController.onChange(value => {
                mesh.material = value === 'Matcap' ? materials.matcapMaterial
                    : value === 'Normal' ? materials.normalMaterial
                        : materials.phongMaterial;

                // Only show the Phong color when Phong is active
                if (value === 'Phong') phongColorController.show();
                else phongColorController.hide();
            });

            gui.add(options, 'mesh').name('Wireframe').onChange(v => {
                if (v) scene.add(wireframeMesh);
                else scene.remove(wireframeMesh);
            });

            gui.add(options, 'autoRotate').name('Auto Rotate').onChange(v => {
                controls.autoRotate = v;
            });

            gui.add(options, 'knot').name('Show Knot').onChange(v => {
                meshKnot.visible = v;
            });

            gui.add(options, 'inversion').name('Show Inversion').onChange(v => {
                mesh.visible = v;
                wireframeMesh.visible = options.mesh && v;
            });

            gui.add(options, 'sphere').name('Show Sphere').onChange(v => {
                meshSphere.visible = v;
                wireframeSphere.visible = v;
            });

            gui.add(options, 'size', 0.01, 2, 0.01).name('Dilate').onChange(updateGeometry);
            gui.add(options, 'translate', -3, 3, 0.01).name('Translate').onChange(updateGeometry);

            gui.close();
        }

        function updateGeometry() {
            geometry.dispose();
            geometry = new ParametricGeometry((u, v, target) =>
                torusknotSurface(u, v, target, options.size, options.translate), meshRes.x, meshRes.y);
            geometry.rotateX(Math.PI / 2);
            mesh.geometry = geometry;
            wireframeMesh.geometry = geometry;

            geometryKnot.dispose();
            geometryKnot = new ParametricGeometry((u, v, target) =>
                trefoilknotSurface(u, v, target, 4 * PI, 2 * PI, options.size, options.translate, 0, 0), 64, 64);
            geometryKnot.rotateX(Math.PI / 2);
            meshKnot.geometry = geometryKnot;
        }

        // UI
        commonUI();

        // Helpers
        scene.add(new THREE.GridHelper(10, 10));
        scene.add(new THREE.AxesHelper(1));

        controls.autoRotate = false;
        controls.autoRotateSpeed = -0.9;

        // Animation loop
        function tick() {
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(tick);
        }
        tick();



    </script>
</body>

</html>