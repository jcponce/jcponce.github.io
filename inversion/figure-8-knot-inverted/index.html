<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Figure 8 knot Inverted</title>
    <!--
  <link rel="stylesheet" href="./style.css">-->

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            overflow: hidden;
        }

        .webgl {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }

        .lil-gui {
            --font-size: 1.1rem;
            --width: 350px;
            --name-width: 43%;
        }

        .lil-gui .controller input[type="number"] {
            /* make numbers bigger */
            font-size: 1.1rem;
        }
    </style>
</head>

<body>
    <canvas class="webgl"></canvas>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"
        crossorigin="anonymous"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.179.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.179.0/examples/jsm/"
      }
    }
  </script>
    <script type="module">

        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        // GUI setup
        const gui = new GUI();
        const options = {
            material: 'Matcap',
            mesh: false,
            size: 0.3,
            translate: -0.19,
            autoRotate: false,
            color: '#049ef4',    // Phong color (controller hidden unless Phong)
            knot: true,
            inversion: true,
            sphere: true,
            axis: false,
            grid: true
        };
        
        // Shorthands
        const cos = Math.cos;
        const sin = Math.sin;
        const pow = Math.pow;
        const PI = Math.PI;

        // function components(u, v){
        //     const E = 0.3;
        //     const h = 0.4;
        //     return {
        //         x: sin((3 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u)))*(1.5+sin(1.5*v)/4) - (1.5+sin(1.5*v)/4)),
        //         y: cos((3 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u)))*(1.5+sin(1.5*v)/4) - (1.5+sin(1.5*v)/4)),
        //         z: (-2*h*sin((2 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u))) - 1)) + 0.1*cos(1.5*v)
        //     }
        // }

        function trefoilKnotInvertedSurface(u, v, target, size, translate) {
            u = 2 * PI * u;
            v = 2 * PI * v;

            const E = 0.3;
            const h = 0.4;

            const XX = -size * (sin((3 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u)))*(1.5+sin(1.5*v)/4) - (1.5+sin(1.5*v)/4))) + translate;
            const YY = size * (cos((3 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u)))*(1.5+sin(1.5*v)/4) - (1.5+sin(1.5*v)/4)));
            const ZZ = size * ((-2*h*sin((2 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u))) - 1)) + 0.1*cos(1.5*v));

            const norm2 = pow(XX, 2) + pow(YY, 2) + pow(ZZ, 2);
            target.set(0.5 * XX / norm2, 0.5 * YY / norm2, 0.5 * ZZ / norm2);
        }

        function sphereSurface(u, v, target, r, uComponent, vComponent) {
            u = uComponent * u;
            v = vComponent * v;
            target.set(r * cos(u) * sin(v), r * sin(u) * sin(v), r * cos(v));
        }

        function trefoilknotSurface(u, v, target, uComponent, vComponent, size, tx, ty, tz) {
            u = uComponent * u;
            v = vComponent * v;

            const E = 0.3;
            const h = 0.4;
            const x = -size * (sin((3 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u)))*(1.5+sin(1.5*v)/4) - (1.5+sin(1.5*v)/4))) + tx;
            const y = size * (cos((3 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u)))*(1.5+sin(1.5*v)/4) - (1.5+sin(1.5*v)/4))) + ty;
            const z = size * ((-2*h*sin((2 * u)) * ((E * sin((4 * u))) + 1) / ((E * sin((4 * u))) - 1)) + 0.1*cos(1.5*v)) + tz;
            target.set(x, y, z);
        }

        function createMaterials(options) {
            const textureLoader = new THREE.TextureLoader();
            const matcapTexture = textureLoader.load('../assets/textures/matcaps/15.png');

            return {
                matcapMaterial: new THREE.MeshMatcapMaterial({ matcap: matcapTexture, side: THREE.DoubleSide }),
                normalMaterial: new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }),
                phongMaterial: new THREE.MeshPhongMaterial({ color: options.color, shininess: 100, side: THREE.DoubleSide }),
                wireframeMaterial: new THREE.MeshBasicMaterial({ color: 0x1a1a1a, wireframe: true })
            };
        }

        function setupScene(canvas) {
            // Z is up
            THREE.Object3D.DEFAULT_UP.set(0, 0, 1);
            const scene = new THREE.Scene();

            // Camera
            const sizes = { width: window.innerWidth, height: window.innerHeight };
            const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000);
            camera.position.set(-2, 2, 2.6);
            scene.add(camera);

            // Renderer (white background, opaque)
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
            renderer.setSize(sizes.width, sizes.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0xf2f2f2, 1); // background

            // Controls
            const controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true;

            // Lights
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);
            scene.add(new THREE.AmbientLight(0x404040));

            // Resize
            window.addEventListener('resize', () => {
                sizes.width = window.innerWidth;
                sizes.height = window.innerHeight;
                camera.aspect = sizes.width / sizes.height;
                camera.updateProjectionMatrix();
                renderer.setSize(sizes.width, sizes.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            });

            return { scene, camera, renderer, controls };
        }

        

        // Scene setup
        const canvas = document.querySelector('canvas.webgl');
        const { scene, camera, renderer, controls } = setupScene(canvas);

        // Materials
        const materials = createMaterials(options);

        // Geometry: inversion surface
        const meshRes = { x: 1000, y: 100 };
        let geometry = new ParametricGeometry((u, v, target) =>
            trefoilKnotInvertedSurface(u, v, target, options.size, options.translate), meshRes.x, meshRes.y);

        let mesh = new THREE.Mesh(geometry, materials.matcapMaterial);
        scene.add(mesh);

        // Geometry: trefoil knot
        let geometryKnot = new ParametricGeometry((u, v, target) =>
            trefoilknotSurface(u, v, target, 4 * PI, 2 * PI, options.size, options.translate, 0, 0), 228, 228);

        let meshKnot = new THREE.Mesh(geometryKnot, new THREE.MeshPhongMaterial({
            color: '#00ffff',
            shininess: 200,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        }));
        scene.add(meshKnot);

        // Geometry: sphere
        let geometrySphere = new ParametricGeometry((u, v, target) =>
            sphereSurface(u, v, target, 1, 2 * PI, PI), 24, 24);

        let materialSphere = new THREE.MeshPhongMaterial({
            color: '#000',
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.01,
            wireframe: true
        });
        let meshSphere = new THREE.Mesh(geometrySphere, materialSphere);
        scene.add(meshSphere);

        const wireframeSphere = new THREE.LineSegments(
            new THREE.WireframeGeometry(geometrySphere),
            new THREE.LineBasicMaterial({ color: 0xbfbfbf })
        );
        scene.add(wireframeSphere);

        // Wireframe mesh for inversion
        let wireframeMesh = new THREE.Mesh(geometry, materials.wireframeMaterial);

        // Visibility defaults
        mesh.visible = options.inversion;
        meshKnot.visible = options.knot;
        meshSphere.visible = wireframeSphere.visible = options.sphere;

        // GUI
        function commonUI() {
            // Style selector
            const styleController = gui.add(options, 'material', ['Matcap', 'Normal', 'Phong']).name('Style');

            // Phong color controller (create once, hide/show as needed)
            const phongColorController = gui
                .addColor(options, 'color')
                .name('Phong Color')
                .onChange(v => {
                    materials.phongMaterial.color.set(v);
                });

            // Hide initially unless Phong is already selected
            if (options.material !== 'Phong') phongColorController.hide();

            // React to style change
            styleController.onChange(value => {
                mesh.material = value === 'Matcap' ? materials.matcapMaterial
                    : value === 'Normal' ? materials.normalMaterial
                        : materials.phongMaterial;

                // Only show the Phong color when Phong is active
                if (value === 'Phong') phongColorController.show();
                else phongColorController.hide();
            });

            gui.add(options, 'mesh').name('Wireframe').onChange(v => {
                if (v) scene.add(wireframeMesh);
                else scene.remove(wireframeMesh);
            });

            gui.add(options, 'autoRotate').name('Auto Rotate').onChange(v => {
                controls.autoRotate = v;
            });

            gui.add(options, 'knot').name('Show Knot').onChange(v => {
                meshKnot.visible = v;
            });

            gui.add(options, 'inversion').name('Show Inversion').onChange(v => {
                mesh.visible = v;
                wireframeMesh.visible = options.mesh && v;
            });

            gui.add(options, 'sphere').name('Show Sphere').onChange(v => {
                meshSphere.visible = v;
                wireframeSphere.visible = v;
            });

            gui.add(options, 'axis').name('Show Axis').onChange(v => {
                tubeAxes.visible = v;
            });

            gui.add(options, 'grid').name('Show Grid').onChange(v => {
                gridHelper.visible = v;
            });

            gui.add(options, 'size', 0.01, 2, 0.01).name('Dilate').onChange(updateGeometry);
            gui.add(options, 'translate', -3, 3, 0.01).name('Translate').onChange(updateGeometry);

            gui.close();

        }

        function updateGeometry() {
            geometry.dispose();
            geometry = new ParametricGeometry((u, v, target) =>
                trefoilKnotInvertedSurface(u, v, target, options.size, options.translate), meshRes.x, meshRes.y);

            mesh.geometry = geometry;
            wireframeMesh.geometry = geometry;

            geometryKnot.dispose();
            geometryKnot = new ParametricGeometry((u, v, target) =>
                trefoilknotSurface(u, v, target, 4 * PI, 2 * PI, options.size, options.translate, 0, 0), 228, 228);

            meshKnot.geometry = geometryKnot;
        }

        // UI
        commonUI();

        // Helpers
        const gridHelper = new THREE.GridHelper(10, 10);
        gridHelper.rotation.x = Math.PI / 2; // rotate 90° around x-axis
        gridHelper.visible = options.grid;
        scene.add(gridHelper);

        function createTubeAxes(size = 5, radius = 0.05) {
            const axes = new THREE.Group();

            const materials = [
                new THREE.MeshBasicMaterial({ color: 0xff0000 }), // X
                new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // Y
                new THREE.MeshBasicMaterial({ color: 0x0000ff }), // Z
            ];

            function makeAxis(from, to, material) {
                const direction = new THREE.Vector3().subVectors(to, from);
                const length = direction.length();
                const midpoint = new THREE.Vector3().addVectors(from, to).multiplyScalar(0.5);

                const geometry = new THREE.CylinderGeometry(radius, radius, length, 16);
                const mesh = new THREE.Mesh(geometry, material);

                // orient cylinder
                mesh.position.copy(midpoint);
                mesh.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0), // default cylinder up
                    direction.clone().normalize()
                );

                return mesh;
            }

            axes.add(makeAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(size, 0, 0), materials[0])); // X
            axes.add(makeAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, size, 0), materials[1])); // Y
            axes.add(makeAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, size), materials[2])); // Z

            return axes;
        }

        const tubeAxes = createTubeAxes(1, 0.01);
        tubeAxes.visible = options.axis;
        scene.add(tubeAxes);

        //scene.add(new THREE.AxesHelper(1));

        controls.autoRotate = false;
        controls.autoRotateSpeed = -0.9;

        // Animation loop
        function tick() {
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(tick);
        }
        tick();


    </script>

</body>

</html>